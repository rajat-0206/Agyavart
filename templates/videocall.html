<!DOCTYPE html>
<html>
<head>
	<title>Video Call</title>
	<script type='text/javascript' src='https://cdn.scaledrone.com/scaledrone.min.js'></script>
</head>
<body>
	<h1>CALLING {{RecName}}</h1>
	<h2>{{RecName}} {{warning}}</h2>
<video id="localVideo" autoplay muted></video>
<video id="remoteVideo" autoplay></video>

<button onclick="callcut()">End Call</button>
</body>

<script type="text/javascript">
const roomHash = "{{roomcode}}";

const configuration = {
 iceServers: [{
   urls: 'stun:stun.l.google.com:19302' // Google's public STUN server
 }]
};

function onSuccess() {};
function onError(error) {
  console.error(error);
};

// Room name needs to be prefixed with 'observable-'
const roomName = 'observable-' + roomHash;
let room;
const drone = new ScaleDrone('QrLN4zJgXAKY5rco');
 
drone.on('open', error => {
 if (error) {
   return onError(error);
 }
 room = drone.subscribe(roomName);
 room.on('open', error => {
   if (error) {
     onError(error);
   }
 });
 // We're connected to the room and received an array of 'members'
 // connected to the room (including us). Signaling server is ready.
 room.on('members', members => {
   if (members.length >= 3) {
     return alert('The room is full');
   }
   // If we are the second user to connect to the room we will be creating the offer
   const isOfferer = members.length === 2;
   startWebRTC(isOfferer);
   startListentingToSignals();
   console.log(members.length);
 });
});

function sendMessage(message) {
 drone.publish({
   room: roomName,
   message
 });
}

let pc;
function startWebRTC(isOfferer) {
 pc = new RTCPeerConnection(configuration);
 
 // 'onicecandidate' notifies us whenever an ICE agent needs to deliver a
 // message to the other peer through the signaling server
 pc.onicecandidate = event => {
   if (event.candidate) {
     sendMessage({'candidate': event.candidate});
   }
 };
 
 // If user is offerer let the 'negotiationneeded' event create the offer
 if (isOfferer) {
   pc.onnegotiationneeded = () => {
     pc.createOffer().then(localDescCreated).catch(onError);
   }
 }
 
 // When a remote stream arrives display it in the #remoteVideo element
 pc.onaddstream = event => {
   remoteVideo.srcObject = event.stream;
   if(!remoteVideo.srcObject){
   	console.log("recieving closed");
   }
 };
 
 navigator.mediaDevices.getUserMedia({
   audio: true,
   video: true,
 }).then(stream => {
   // Display your local video in #localVideo element
   localVideo.srcObject = stream;
   // Add your stream to be sent to the conneting peer
   pc.addStream(stream);
 }, onError);
}

function startListentingToSignals() {
 // Listen to signaling data from Scaledrone
 room.on('data', (message, client) => {
   // Message was sent by us
   if (!client || client.id === drone.clientId) {
     return;
   }
   if (message.sdp) {
     // This is called after receiving an offer or answer from another peer
     pc.setRemoteDescription(new RTCSessionDescription(message.sdp), () => {
       // When receiving an offer lets answer it
       if (pc.remoteDescription.type === 'offer') {
         pc.createAnswer().then(localDescCreated).catch(onError);
       }
     }, onError);
   } else if (message.candidate) {
     // Add the new ICE candidate to our connections remote description
     pc.addIceCandidate(
       new RTCIceCandidate(message.candidate), onSuccess, onError
     );
   }
 });
}

function localDescCreated(desc) {
 pc.setLocalDescription(
   desc,
   () => sendMessage({'sdp': pc.localDescription}),
   onError
 );
}

function callcut(){
	url = "/cutcall?recipient="+"{{recipient}}";
  location.href = url;
}

setInterval(function(){
	var xhttp = new XMLHttpRequest();
  xhttp.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
      if(this.responseText=='ended')
      {
         window.history.back();
      }
        }
        };
  xhttp.open("GET","/status", true);
  xhttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
  xhttp.send();
},2000);
</script>
</html>